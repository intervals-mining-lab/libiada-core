<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ChainAnalises</name>
    </assembly>
    <members>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Chain">
            <summary>
             Класс цепь
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.ChainWithCharacteristic">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.BaseChain">
            <summary>
             
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.EventTheory.Space">
            <summary>
             Данный класс реализует простраство. 
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.Root.IBaseObject">
            <summary>
            Интерфейс являющийся базовым для всех (наследуемый всеми) классами библиотеки
            Позоляет корректно сравнивать объекты и делать их копии.
             Любой элемент данных наследует данный интерфейс.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.Root.IBaseObject.Clone">
            <summary>
             Метод клонирования объекта
            </summary>
            <returns>Копию данного объекта</returns>
        </member>
        <member name="M:ChainAnalises.Classes.Root.IBaseObject.Equals(System.Object)">
            <summary>
             Метод реализующий отношение эквивалентности
            </summary>
            <param name="obj">Объект c которым происходит проверка на эквивалентность</param>
            <returns>True если объекты эквивалентны, иначе false</returns>
        </member>
        <member name="M:ChainAnalises.Classes.Root.IBaseObject.GetBin">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.#ctor">
            <summary>
             Конструктор
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.EqualsAsSpace(ChainAnalises.Classes.EventTheory.Space)">
            <summary>
             Метод реализует отношение эквивалентности.
             Два пространста эквиваленты при условии эквивалентности их пространств, алфавитов
             и порядка следования элементов.
            </summary>
            <param name="discrete">Объект прострнства с которым сравниваем</param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.FillBin(ChainAnalises.Classes.EventTheory.SpaceBin)">
            <summary>
            </summary>
            <param name="Temp"></param>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.#ctor(ChainAnalises.Classes.EventTheory.SpaceBin)">
            <summary>
            </summary>
            <param name="bin"></param>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.AddDimension(ChainAnalises.Classes.EventTheory.Dimension)">
            <summary>
             Увеличивает размерность пространства.
             При передачи в качесвте параметра null вызыватся null исключение.
             Измерение копируестя, последующее изменение объекта класса измерние, передаваемого в качестве
             параметра, никак не скажется на состоянии пространства.
             При добавлении измерения в пространство (минимум одномерное) в случае если 
             предварительно в пространство были установденнны элементы они сохранят свои позиции. 
            </summary>
             <example>
              BaseSpace = new SpaceDiscrete();
             
             Dimension dm1 = new Dimension(0, 10);
             Dimension dm2 = new Dimension(-1, 10);
             
             BaseSpace.AddDimension(dm1);
             
             ValueInt int1 = new ValueInt(1);
             ValueInt int2 = new ValueInt(6);
             ValueInt int3 = new ValueInt(1);
             
             Place Pl = BaseSpace.GetPlacePattern(); 
             
             Pl.SetValues(new long[] { 1 });
             BaseSpace.AddItem(int1, Pl);
             
             Pl.SetValues(new long[] { 2 });
             BaseSpace.AddItem(int2, Pl);
             
             Pl.SetValues(new long[] { 3 });
             BaseSpace.AddItem(int3, Pl);
             
             Pl.SetValues(new long[] { 4 });
             BaseSpace.AddItem(int3, Pl);
             
             Pl.SetValues(new long[] { 5 });
             BaseSpace.AddItem(int1, Pl);
             
             Pl.SetValues(new long[] { 6 });
             BaseSpace.AddItem(int2, Pl);
             
             BaseSpace.AddDimension(dm2);
             
             Pl = BaseSpace.GetPlacePattern();
             
             Assert.AreEqual(int1, BaseSpace.GetItem(Pl.SetValues(new long[] { 1, 0 })));
             Assert.IsTrue(int2.Equals(BaseSpace.GetItem(Pl.SetValues(new long[] { 2, 0 }))));
             Assert.IsTrue(int3.Equals(BaseSpace.GetItem(Pl.SetValues(new long[] { 3, 0 }))));
             Assert.IsTrue(int3.Equals(BaseSpace.GetItem(Pl.SetValues(new long[] { 4, 0 }))));
             Assert.IsTrue(int1.Equals(BaseSpace.GetItem(Pl.SetValues(new long[] { 5, 0 }))));
             Assert.IsTrue(int2.Equals(BaseSpace.GetItem(Pl.SetValues(new long[] { 6, 0 }))));
             </example>
            <param name="Dimension">Объект измерение</param>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.DeleteDimesnions">
            <summary>
             Удаляет все измерения пространтсва
             И очищает весь алфавит.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.GetDimension(System.Int32)">
            <summary>
             Позволяет получить одно из измерений пространтсва.
            </summary>
            <param name="i">Номер измерния в пространстве</param>
            <returns>Объект измерение</returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.DimensionCount">
            <summary>
             Количество измерений пространства.
             Размерность пространства.
            </summary>
            <returns>Возвращает INT64. Результат всегда >=0</returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.GetPlacePattern">
            <summary>
             Позволяет получить место принадлежащее данному пространству.
             Используйте данное место (заполнив значения для каждой размерности) в качстве параметра для методов требующий объект класса место.
            </summary>
            <returns>Объект Место, совместимый с данным пространством</returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.RemoveAt(ChainAnalises.Classes.EventTheory.Place)">
            <summary>
             Удаляет величину из места place
            </summary>
            <param name="place">Объект место величину в котром нужно очистить, принадлежащее протранству</param>
            <exception cref="T:System.Exception">В случае если место выходит за пределы пространства вызывается исключение</exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.GetItem(ChainAnalises.Classes.EventTheory.Place)">
            <summary>
             Возвращает величину из места place
            </summary>
            <param name="place">Объект место из которого нужно выбрать величину, принадлежащее протранству</param>
            <returns>Возвращает объект типа I если место имеет ну пусто наполнение, в противном случае null</returns>
            <exception cref="T:System.Exception">В случае если место выходит за пределы пространства вызывается исключение</exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Space.AddItem(ChainAnalises.Classes.Root.IBaseObject,ChainAnalises.Classes.EventTheory.Place)">
            <summary>
             Помещает величину в место place
            </summary>
            <param name="value">Объект типа I который требуется поместить в меcто Place</param>
            <param name="place">Объект типа меcто Place в котрый требуется поместить величину value</param>
            <exception cref="T:System.Exception">В случае если место выходит за пределы пространства вызывается исключение</exception>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.Space.Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <returns>
            The current element in the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The enumerator is positioned before the first element of the collection or after the last element. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.Space.Building">
            <summary>
             Строй.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.Space.Alpahbet">
            <summary>
             Возвращает алфавит на котром определны все элементы пространства.
             Алфавит является копией и его последующее изменение не как не скажется на состоянии
             пространства. алфавит не содержит псеводовеличины.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.Space.PlaceCount">
            <summary>
             Свойство возвращает кол-во элементов в пространстве.
             <example>
             Dimension D1 = new Dimension(0, 10);
             
             BaseSpace.AddDimension(D1);
             Assert.AreEqual(D1.Length, BaseSpace.ItemCount);
             
             Dimension D2 = new Dimension(-10, 10);
             
             BaseSpace.AddDimension(D2);
             Assert.AreEqual(D1.Length * D2.Length, BaseSpace.ItemCount);
             </example>   
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.BaseChain.Get(System.Int32)">
            <summary>
             Метод позволяющий получить элемент по индексу
             В случае выхода за границы цепи вызывается исключение
            </summary>
            <param name="index">Индекс элемента</param>
            <returns>Возвращает элемент</returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.BaseChain.Add(ChainAnalises.Classes.Root.IBaseObject,System.Int32)">
            <summary>
             Метод похволяющий установить элемент по индексу
            </summary>
            <param name="baseObject">Устанвалеваемый элемент </param>
            <param name="index">Номер позиции в цепи куда устанавливается элемент</param>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.BaseChain.RemoveAt(System.Int32)">
            <summary>
             Метод удаляющий элемент с позиции цепи 
             В случае выхода за границы цепи вызывается исключение
            </summary>
            <param name="index">Номер позиции</param>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.BaseChain.#ctor(System.Int32)">
            <summary>
            </summary>
            <param name="length"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.BaseChain.ClearAndSetNewLength(System.Int32)">
            <summary>
            </summary>
            <param name="length"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.BaseChain.#ctor(ChainAnalises.Classes.IntervalAnalysis.BaseChainBin)">
            <summary>
            </summary>
            <param name="Bin"></param>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.BaseChain.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.BaseChain.#ctor(System.String)">
            <summary>
             Создает цепь из строки символов
            </summary>
            <param name="s"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.BaseChain.GetBin">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.BaseChain.Clone">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.BaseChain.Length">
            <summary>
             Длинна цепи.
             Только для чтения
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.BaseChain.Item(System.Int32)">
            <summary>
             Свойстово позволяет получить доступ к элементу цепи по индексу
             В случае выхода за границы цепи вызывается исключение
            </summary>
            <param name="index">номер элемента</param>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.AuxiliaryInterfaces.IDataForCalculator">
            <summary>
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.AuxiliaryInterfaces.IDataForCalculator.CommonIntervals">
            <summary>
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.AuxiliaryInterfaces.IDataForCalculator.StartInterval">
            <summary>
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.AuxiliaryInterfaces.IDataForCalculator.EndInterval">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.ChainWithCharacteristic.ClearAndSetNewLength(System.Int32)">
            <summary>
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.ChainWithCharacteristic.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.ChainWithCharacteristic.GetCharacteristic(ChainAnalises.Classes.IntervalAnalysis.LinkUp,ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.ICharacteristicCalculator)">
            <summary>
            </summary>
            <param name="Link"></param>
            <param name="CharacteristicType"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.ChainWithCharacteristic.InjectIntoCharacteristic(System.Type,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="type"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.ChainWithCharacteristic.Intervals(ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="linkUp"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.ChainWithCharacteristic.GetBin">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.ChainWithCharacteristic.FillBin(ChainAnalises.Classes.IntervalAnalysis.ChainWithCharacteristicBin)">
            <summary>
            </summary>
            <param name="Bin"></param>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.ChainWithCharacteristic.GetCharacteristicList">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.AuxiliaryInterfaces.IChainDataForCalculaton">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.AuxiliaryInterfaces.IChainDataForCalculaton.IUniformChain(System.Int32)">
            <summary>
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Chain.#ctor(System.Int32)">
            <summary>
             Конструктор 
             При указании длинны следует понимать что цепь начинается с 0 элемента.
            </summary>
            <param name="length">Длинна цепи</param>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Chain.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Chain.ClearAndSetNewLength(System.Int32)">
            <summary>
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Chain.#ctor(ChainAnalises.Classes.IntervalAnalysis.ChainBin)">
            <summary>
            </summary>
            <param name="Bin"></param>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Chain.#ctor(System.String)">
            <summary>
             Кнструктор, создает цепь из строки символов
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Chain.FillClone(ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
            
            </summary>
            <param name="temp"></param>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Chain.UniformChain(ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
            </summary>
            <param name="baseObject"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Chain.GetUniformChain(System.Int32)">
            <summary>
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Chain.InjectIntoCharacteristic(System.Type,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="type"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Chain.FillBin(ChainAnalises.Classes.IntervalAnalysis.ChainBin)">
            <summary>
            </summary>
            <param name="Bin"></param>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.ChainBin">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.ChainWithCharacteristicBin">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.BaseChainBin">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.EventTheory.SpaceBin">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.Root.IBin">
            <summary>
             Интерфейс Bin классов, промежуточных между
             Soap классами и естественными классами библиотеки.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.Root.IBin.GetInstance">
            <summary>
             Создаёт из Bin объекта соответсвующий ему объект библиотеки.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.UniformChain">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.UniformChain.#ctor(System.Int32,ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
            </summary>
            <param name="length"></param>
            <param name="Message"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.UniformChain.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.UniformChain.#ctor(ChainAnalises.Classes.IntervalAnalysis.UniformChainBin)">
            <summary>
            </summary>
            <param name="uchain"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.UniformChain.GetBin">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.UniformChain.FillBin(ChainAnalises.Classes.IntervalAnalysis.UniformChainBin)">
            <summary>
            </summary>
            <param name="Bin"></param>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.UniformChain.Message">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.UniformChainBin">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.IdentificationInformation">
            <summary>
             Количество идентифицирующих информаций приходящихся на одно значащее сообщение.
             Энтропия, количество информации.
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.ICharacteristicCalculator">
            <summary>
             Интерфейс калькулатора
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.ICharacteristicCalculator.Calculate(ChainAnalises.Classes.IntervalAnalysis.UniformChain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.ICharacteristicCalculator.Calculate(ChainAnalises.Classes.IntervalAnalysis.Chain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.ICharacteristicCalculator.GetCharacteristicName">
            <summary>
             Возвращает имя характеристики вычисляемой калькулятором
            </summary>
            <returns>Имя в виде строки, например Entropy</returns>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.CutLengthVocabularyEntropy">
            <summary>
             Энтропия словаря по Садовскому.
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum">
            <summary>
             
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.Length">
            <summary>
             Длинна как сумма длин интервалов.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.AlphabetPower">
            <summary>
             Мощность алфавита.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.AverangeRemoteness">
            <summary>
             Среднегеометрическая удалённость.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.Count">
            <summary>
             Количество элементов.
             Для однородной цепи это количество 
             непустых элементов.
             Для неоднородной цепи это её длина.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.CutLength">
            <summary>
             Длина обрезания по Садовскому.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.IntervalsCount">
            <summary>
             Количество интервалов в зависимости от привязки.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.Entropy">
            <summary>
             Количество идентифицирующих информаций приходящихся на одно значащее сообщение.
             Энтропия, количество информации.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.Volume">
            <summary>
             Объём цепи. Произведение длин всех её интервалов.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.PhantomMessageCount">
            <summary>
             Число возможных цепочек которые можно сгенерировать 
             из данной цепочки, содержащей фантомные сообщения.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.CutLengthVocabularyEntropy">
            <summary>
            Энтропия словаря по Садовскому. 
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.Regularity">
            <summary>
             Регулярность.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.Propability">
            <summary>
            Вероятность (частота).
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.DescriptiveInformation">
            <summary>
             Число описательных информаций.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.Gamut">
            <summary>
             Удалённость.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.ArithmeticMean">
            <summary>
             Среднее арифметическое значение длин интервалов.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.NomalizationGamut">
            <summary>
             Удалённость приходящаяся на одно сообщение.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.Periodicity">
            <summary>
             Периодичность.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.GeometricMiddling">
            <summary>
             Среднегеометрический интервал.
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsEnum.NormalizedAverageRemoteness">
            <summary>
            Нормализованный среднегеометрический интервал
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Length">
            <summary>
             Длинна как сумма длин интервалов.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Length.Calculate(ChainAnalises.Classes.IntervalAnalysis.UniformChain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            Для однородной цепи считается по первому 
            или последнему значащему сообщению в зависимости от привязки.
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.CutLength">
            <summary>
             Длина обрезания по Садовскому.
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.IntervalsCount">
            <summary>
             Количество интервалов в зависимости от привязки.
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Gamut">
            <summary>
             Удалённость.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Gamut.Calculate(ChainAnalises.Classes.IntervalAnalysis.Chain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Regularity">
            <summary>
             Регулярность.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Regularity.Calculate(ChainAnalises.Classes.IntervalAnalysis.Chain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.GeometricMiddling">
            <summary>
             Среднегеометрический интервал.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.GeometricMiddling.Calculate(ChainAnalises.Classes.IntervalAnalysis.Chain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.Root.SimpleTypes.ValueInt">
            <summary>
             Класс представляющий элемент - целочисленное значение
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueInt.#ctor(System.Int32)">
            <summary>
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueInt.#ctor(ChainAnalises.Classes.Root.SimpleTypes.ValueIntBin)">
            <summary>
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueInt.Clone">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueInt.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            true if the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>; otherwise, false.
            </returns>
            
            <param name="obj">The <see cref="T:System.Object"></see> to compare with the current <see cref="T:System.Object"></see>. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueInt.op_Implicit(ChainAnalises.Classes.Root.SimpleTypes.ValueInt)~System.Int32">
            <summary>
            </summary>
            <param name="From"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueInt.op_Implicit(System.Int32)~ChainAnalises.Classes.Root.SimpleTypes.ValueInt">
            <summary>
            </summary>
            <param name="from"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.Root.SimpleTypes.ValueIntBin">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueIntBin.#ctor(System.Int32)">
            <summary>
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:ChainAnalises.Classes.EventTheory.Place">
            <summary>
             Класс Место
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Place.#ctor(System.Collections.ArrayList)">
            <summary>
             Конструктор
            </summary>
            <param name="dimensionality">Размерность пространтсва которому принаджелит ланное место</param>
            <exception cref="T:System.Exception">Экземпляр класса</exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Place.SetValue(System.Int64,System.Int64)">
            <summary>
             Устанваливает значение value по измерению под номером index 
            </summary>
            <param name="value">Значение</param>
            <param name="index">Номер измерения</param>
            <exception cref="T:System.Exception">При попытке установить значение не существующему измерению или значение выходит за область определения измерния вызыватся исключение</exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Place.SetValues(System.Int64[])">
            <summary>
            Устанавливает значения по всем измерениям из массива.
            </summary>
            <param name="value">Массив значений</param>
            <exception cref="T:System.Exception">В случае если размерности массива и места не совпадают и в случае если одно из значений выходит за пределы области определения соответствующего измерния вызывается исключение</exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Place.GetValue(System.Int64)">
            <summary>
             Возвращяет значение по измерению под номером index 
            </summary>
            <param name="index">Номер измерения</param>
            <exception cref="T:System.Exception">При попытке получить значение по несуществующему измерению вызыватся исключение</exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Place.GetValues">
            <summary>
             Возвращает массив значений по всем измерениям
            </summary>
            <returns>Массив значений по всем измерениям</returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Place.CompatibleTo(ChainAnalises.Classes.EventTheory.Place)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Place.Neighbour(ChainAnalises.Classes.EventTheory.Place)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Place.EqualsAsPlace(ChainAnalises.Classes.EventTheory.Place)">
            <summary>
             Сравнивает два места как места
            </summary>
            <param name="after">место с которым сравниваем. Если null то возвращает false</param>
            <returns>True если места принадлежат одному пространству и имеют одинаковые значения иначе false</returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Place.Clone">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.Place.Dimension">
            <summary>
            Возвращает массив измерний пространства которому принадлежит место 
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.Place.Count">
            <summary>
             Возвращает размерность пространства которому принадлежит место.
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.EventTheory.Event">
            <summary>
             Класс реализующий Событие
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.AddDimension(ChainAnalises.Classes.EventTheory.Dimension)">
            <summary>
            </summary>
            <param name="Dimension"></param>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.DeleteDimesnions">
            <summary>
             Удаляет все измерения пространтсва
             И очищает весь алфавит.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.GetDimension(System.Int32)">
            <summary>
             Позволяет получить одно из измерение пространтсва 
            </summary>
            <param name="i">Номер измерния в пространстве</param>
            <returns>Объект измерения</returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.DimensionCount">
            <summary>
             Количество измерений пространства.
             Размерность пространства.
            </summary>
            <returns>Возвращает INT64. Результат всегда >=0</returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.AddToReadRule(ChainAnalises.Classes.EventTheory.Place,ChainAnalises.Classes.EventTheory.Place)">
            <summary>
             Добавляет value место в правило чтения для места Key.
             Key и Value - соседнии места принадлежашие данному событию, если это ограницение нарушается 
             выкидывается исключение
            </summary>
            <param name="Key">Место в правило для которого добавляется Value</param>
            <param name="Value">Место которое добавляется в правило для места Key</param>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.AddToReadRule(ChainAnalises.Classes.EventTheory.Place,ChainAnalises.Classes.EventTheory.ReadRule)">
            <summary>
             Добавляет правило чтения Value для места Key.
             Правило чтения Value должно быть определено для эквивалентного Key места, принадлежащего данному событию, 
             в противном случае выкидывается исключение.
             В случае если для места Key уже определно правило то это правило объединяется с 
             Value
            </summary>
            <param name="Key">Место в правило для которого добавляется Value</param>
            <param name="Value">Место которое добавляется в правило для места Key</param>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.RemoveFromReadRule(ChainAnalises.Classes.EventTheory.Place)">
            <summary>
             Удаляет правило из места Key.
             Key должно принадлежать данному событию, иначе вызывается исключение.
            </summary>
            <param name="Key"></param>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.RemoveFromReadRuleAt(System.Int32)">
            <summary>
             Удаляет i-ое правило.
            </summary>
            <param name="index">Номер правила</param>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.GetFromReadRule(ChainAnalises.Classes.EventTheory.Place)">
            <summary>
             Получить правило для места Key.
             Key должно принадлежать данному событию, иначе вызывается исключение.
            </summary>
            <param name="Key"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.GetReadPath(ChainAnalises.Classes.EventTheory.Place,ChainAnalises.Classes.EventTheory.Place)">
            <summary>
            </summary>
            <param name="From"></param>
            <param name="To"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Rapprochement(ChainAnalises.Classes.EventTheory.Event,ChainAnalises.Classes.EventTheory.Event,ChainAnalises.Classes.EventTheory.Place,ChainAnalises.Classes.EventTheory.Place)">
            <summary>
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="apoint"></param>
            <param name="bpoint"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Adding(ChainAnalises.Classes.EventTheory.Event,System.Boolean)">
            <summary>
            </summary>
            <param name="b"></param>
            <param name="absolute_priority"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Add(ChainAnalises.Classes.EventTheory.Event)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.AddRelative(ChainAnalises.Classes.EventTheory.Event)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Joining(ChainAnalises.Classes.EventTheory.Event)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Removing(ChainAnalises.Classes.EventTheory.Event)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Removal(ChainAnalises.Classes.EventTheory.Event)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Removal(System.Object)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Induction(ChainAnalises.Classes.EventTheory.Event)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Deduction(ChainAnalises.Classes.EventTheory.Event)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Syntheses(ChainAnalises.Classes.EventTheory.Event)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Analysis(ChainAnalises.Classes.EventTheory.Event)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Join(ChainAnalises.Classes.EventTheory.Event)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Event.Separation(ChainAnalises.Classes.EventTheory.Event)">
            <summary>
            </summary>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.Event.ReadRuleCount">
            <summary>
             Свойство возвращает кол-во мест для которых определено 
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.TheoryOfSet.Alphabet">
            <summary>
             Данный класс реализует алфавит элементов
             Алфавит это список из уникальных элементов
             Алфавит является классом организованным в соотвествии с паттреном "Значение"
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.TheoryOfSet.Alphabet.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.TheoryOfSet.Alphabet.#ctor(ChainAnalises.Classes.TheoryOfSet.AlphabetBin)">
            <summary>
            </summary>
            <param name="Bin"></param>
        </member>
        <member name="M:ChainAnalises.Classes.TheoryOfSet.Alphabet.GetBin">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.TheoryOfSet.Alphabet.Add(ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
              Реализация добавления элемента в алфавит.
            </summary>
            <param name="o">Добавляемый элемент</param>
            <returns>Возвращает его номер в алфавите</returns>
            <exception cref="T:System.Exception">В случае если такой элемент уже содержится алфавите</exception>
            <exception cref="T:System.NullReferenceException">В случае если добавляемый элемент null</exception>
        </member>
        <member name="M:ChainAnalises.Classes.TheoryOfSet.Alphabet.Remove(System.Int32)">
            <summary>
            Удаление элемента из алфавита по указанному индексу.
            Если индекс меньше 0  или >= мощности алфавата вызывается исключение
            </summary>
            <param name="index">Индекс удаляемого элемента в алфавите</param>
        </member>
        <member name="M:ChainAnalises.Classes.TheoryOfSet.Alphabet.Clone">
            <summary>
            Клонирование алфавита
            </summary>
            <returns>Копию алфавита</returns>
        </member>
        <member name="M:ChainAnalises.Classes.TheoryOfSet.Alphabet.Equals(System.Object)">
            <summary>
            Сравнение алфавита исходного и заданного в параметре
            Два алфавита считаются эквивалентными при условии равномощности алфавитов и эквивалентности их составов
            если в качестве второго объекта передается экземпляр класса отличного от алфавита возвращается 
            объекты считаются не эквивалентными
            </summary>
            <param name="obj"> алфавит сравниваемый с исходным</param>
            <returns>true если алфавиты эквиваленты, иначе false </returns>
        </member>
        <member name="M:ChainAnalises.Classes.TheoryOfSet.Alphabet.EqualsAsAlphabet(ChainAnalises.Classes.TheoryOfSet.Alphabet)">
            <summary>
            Поэлементное сравнение алфавитов
            </summary>
            <param name="a_obj">алфавит который сравнивают с исходным</param>
            <returns>true, если алфавиты равны, иначе false</returns>
        </member>
        <member name="M:ChainAnalises.Classes.TheoryOfSet.Alphabet.IndexOf(ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
             Возвращает индекс объекта в алфавите.
             В случае, если данного объекта нет в алфавите возвращает -1.
            </summary>
            <param name="obj">Объект который ищем в алфавите</param>
            <returns>Индекс объекта в алфавите</returns>
        </member>
        <member name="M:ChainAnalises.Classes.TheoryOfSet.Alphabet.Contains(ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
            Определяет принадлежность объекта к алфавиту
            </summary>
            <param name="obj">Объект</param>
            <returns>True если алфавит содержит данный объект, иначе false</returns>
        </member>
        <member name="P:ChainAnalises.Classes.TheoryOfSet.Alphabet.power">
            <summary>
             Свойство возвращает мощность алфавита.
             Кол-во элементов в алфавите. 
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.TheoryOfSet.Alphabet.Item(System.Int32)">
            <summary>
             Позволяет получить доступ к элементу алфавита по индексу.
             Позволяет записывать и считывать элемент.
             При записи происходит проверка на отсутствие данного объекта в алфавите. 
             В случае успешной исхода данной проверки элемент добавляется в алфавит, 
             в противном этого не происходит, при том класс не уведомляет об этом вненюю среду. 
             Если индекс меньше 0  или >= мощности алфавата вызывается исключение.
            </summary>
            <param name="index">Индекс элемента в алфавите</param>
        </member>
        <member name="T:ChainAnalises.Classes.TheoryOfSet.AlphabetBin">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory">
            <summary>
             Статическая фабрика различных калькуляторов.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.Create(System.String)">
            <summary>
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.P">
            <summary>
             Вероятность (частота).
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.IntervalsCount">
            <summary>
             Количество интервалов в зависимости от привязки.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.CutLength">
            <summary>
             Длина обрезания по Садовскому.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.G">
            <summary>
             Удалённость.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.n">
            <summary>
             Количество элементов.
             Для однородной цепи это количество 
             непустых элементов.
             Для неоднородной цепи это её длина.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.deltaG">
            <summary>
             Среднегеометрический интервал.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.Length">
            <summary>
             Длинна как сумма длин интервалов.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.deltaA">
            <summary>
             Среднее арифметическое значение длин интервалов.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.D">
            <summary>
             Число описательных информаций.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.r">
            <summary>
             Регулярность.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.g">
            <summary>
             Среднегеометрическая удалённость.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.H">
            <summary>
             Количество идентифицирующих информаций приходящихся на одно значащее сообщение.
             Энтропия, количество информации.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.V">
            <summary>
             Объём цепи. Произведение длин всех её интервалов.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.Power">
            <summary>
             Мощность алфавита.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.nG">
            <summary>
             Удалённость приходящаяся на одно сообщение.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.t">
            <summary>
             Периодичность.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.CutLenVocEntropy">
            <summary>
             Энтропия словаря по Садовскому.
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicsFactory.List">
            <summary>
             Список калькуляторов характеристик.
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Periodicity">
            <summary>
             Периодичность.
             Имеет смысл только для однородной цепи.
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.EventTheory.ReadRule">
            <summary>
             Класс реализующий правило чтения
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.ReadRule.Contains(ChainAnalises.Classes.EventTheory.Place)">
            <summary>
            Метод реализует проверку на наличние места в правиле.
            </summary>
            <param name="ToRule">Проверяемое место</param>
            <returns>Возвраает true в случае наличния данного места в правиле, иначе false</returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.ReadRule.#ctor(ChainAnalises.Classes.EventTheory.Place)">
            <summary>
             Конструктор
            </summary>
            <param name="Place">Базовое место для которого используется данное правило</param>
            <exception cref="T:System.NullReferenceException">В случае если базовое место null вызывает исключение.</exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.ReadRule.Add(ChainAnalises.Classes.EventTheory.Place)">
            <summary>
             метод добавляющий отношение "чтения" между базовым и передоваемым местом 
            </summary>
            <param name="Place">Передоваемое место</param>
            <exception cref="T:System.Exception">В случае если передоваемое место уже имеется в списке, не является соседним для базового или является null вызывается исключение</exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.ReadRule.Remove(System.Int32)">
            <summary>
             Метод удаляет место из правила
            </summary>
            <exception cref="T:System.NotImplementedException">В случае если номер места больше количества элементов или меньше 0 вызываается исключение</exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.ReadRule.EqualAsRule(ChainAnalises.Classes.EventTheory.ReadRule)">
            <summary>
             метод реализует отношение эквивальентность
            </summary>
            <param name="B">Правило с которым сравниваем</param>
            <returns>True если места совпадают иначе false</returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.ReadRule.Clone">
            <summary>
             Метод клонирования глубокого
            </summary>
            <returns>Вощвращаяет копию объекта</returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.ReadRule.Add(ChainAnalises.Classes.EventTheory.ReadRule)">
            <summary>
             Метод производящий склеивание двух правил
             Правила должну принадолжать одному месту.
            </summary>
            <param name="rr2">Второе правило</param>
            <returns>ссылку на самого себя</returns>
            <exception cref="T:System.NotImplementedException">выкидывате исключение если правила принадлежть разным точкам или второй аргумент null</exception>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.ReadRule.Count">
            <summary>
             Свойство возвращающее кол-во мест с которыми соеденено данное
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.ReadRule.Item(System.Int32)">
            <summary>
             Свойство позволяющее получить элемент(места) с которым базовое место связанно отнощением "чтения"
            </summary>
            <param name="index">Номер элемента</param>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.LinkUp">
            <summary>
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.LinkUp.Start">
            <summary>
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.LinkUp.End">
            <summary>
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.IntervalAnalysis.LinkUp.Both">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Characteristic">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Characteristic.#ctor(ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.ICharacteristicCalculator)">
            <summary>
            </summary>
            <param name="Type"></param>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Characteristic.#ctor(ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicBin)">
            <summary>
            </summary>
            <param name="Bin"></param>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Characteristic.Value(ChainAnalises.Classes.IntervalAnalysis.UniformChain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="Chain"></param>
            <param name="Link"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Characteristic.GetCurrentValue(ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="Link"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Characteristic.Value(ChainAnalises.Classes.IntervalAnalysis.Chain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="Chain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="P:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Characteristic.GetCharacteristicType">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.CharacteristicBin">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.Statistics.FrequencyList">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.Statistics.FrequencyList.#ctor(ChainAnalises.Classes.Statistics.FrequencyListBin)">
            <summary>
            </summary>
            <param name="bin"></param>
        </member>
        <member name="M:ChainAnalises.Classes.Statistics.FrequencyList.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.Statistics.FrequencyList.FrequencyFromObject(ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
            Возвращает частоту появления объекта
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.Statistics.FrequencyList.Add(ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
            Добавляем элемент в частотный словарь
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.Statistics.FrequencyList.Remove(System.Int32)">
            <summary>
            Удаление элемента из частотного словаря по номеру
            </summary>
            <param name="index">номер удаляемого элемента</param>
        </member>
        <member name="M:ChainAnalises.Classes.Statistics.FrequencyList.Remove(ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:ChainAnalises.Classes.Statistics.FrequencyList.Clone">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.Statistics.FrequencyList.Sum(ChainAnalises.Classes.Statistics.FrequencyList)">
            <summary>
            </summary>
            <param name="intervals"></param>
        </member>
        <member name="P:ChainAnalises.Classes.Statistics.FrequencyList.Frequency">
            <summary>
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.Statistics.FrequencyList.Item(System.Int32)">
            <summary>
            </summary>
            <param name="index"></param>
        </member>
        <member name="P:ChainAnalises.Classes.Statistics.FrequencyList.Keys">
            <summary>
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.Statistics.FrequencyList.Values">
            <summary>
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.Statistics.FrequencyList.Count">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.Statistics.FrequencyListBin">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.Statistics.FrequencyListItemBin">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.Root.SimpleTypes.ValueChar">
            <summary>
             Класс элемент символ
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueChar.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueChar.#ctor(System.Char)">
            <summary>
            Конструктор
            </summary>
            <param name="value">Начальное значение элемента</param>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueChar.#ctor(ChainAnalises.Classes.Root.SimpleTypes.ValueCharBin)">
            <summary>
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueChar.op_Implicit(ChainAnalises.Classes.Root.SimpleTypes.ValueChar)~System.Char">
            <summary>
            </summary>
            <param name="From"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueChar.op_Implicit(System.Char)~ChainAnalises.Classes.Root.SimpleTypes.ValueChar">
            <summary>
            </summary>
            <param name="from"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.Root.SimpleTypes.ValueCharBin">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Count">
            <summary>
             Количество элементов.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Count.Calculate(ChainAnalises.Classes.IntervalAnalysis.UniformChain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            Для однородной цепи это количество 
            непустых элементов.
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Count.Calculate(ChainAnalises.Classes.IntervalAnalysis.Chain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            Для неоднородной цепи это её длина.
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.EventTheory.PsevdoValue">
            <summary>
             Класс реализующий объект псевдо-величина
             Реализованн на основе паттерна Singletone
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.PsevdoValue.Instance">
            <summary>
             Метод позволяющий получить указатель на объект
            </summary>
            <returns>Указатель на объект</returns>
        </member>
        <member name="T:ChainAnalises.Classes.EventTheory.PsevdoValueBin">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.EventTheory.Dimension">
            <summary>
            Данный класс реализует измерение пространства.
            Измерение дискретно. 
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Dimension.#ctor(System.Int64,System.Int64)">
            <param name="min"> Устанавливает минимальную границу по данному измерению</param>
            <param name="max"> Устанавливает максимальную границу по данному измерению</param>
            <example>
              Если измерение определно на интервале (-100,500)
              <code>
                X = new dimension(-100,500);
              </code> 
            </example>
            <summary>
            Конструктор
            В случае, если min>max внешная система не оповещается, а происходит автоматическая замена значений.
            Однако при этом сыбрасывается сообщение в дебагер.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Dimension.#ctor(ChainAnalises.Classes.EventTheory.DimensionBin)">
            <summary>
            </summary>
            <param name="Bin"></param>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Dimension.EqualsAsDimension(ChainAnalises.Classes.EventTheory.Dimension)">
            <summary>
            Метод реализующий отношение эквивалентности
            </summary>
            <param name="obj">Измерение котрое проверяем на эквивалентность даному</param>
            <returns>true если области опрделния измерний совпадают, иначе false</returns>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Dimension.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. <see cref="M:System.Object.GetHashCode"></see> is suitable for use in hashing algorithms and data structures like a hash table.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.Dimension.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"></see> to compare with the current <see cref="T:System.Object"></see>. </param><filterpriority>2</filterpriority>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.Dimension.max">
            <summary>
            Поле класса хранящее максимальную границу области на которой 
            определено измерение. Только для чтения
            </summary>        
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.Dimension.min">
            <summary>
            Поле класса хранящее минимальную границу области на которой 
            определено измерение. Только для чтения
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.Dimension.Length">
            <summary>
             Поле класса хранящее длинну области на которой определено данное измерение
             Только для чтения
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.EventTheory.DimensionBin">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.DimensionBin.GetInstance">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.Statistics.DictionaryEntryBase">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.Statistics.DictionaryEntryBase.#ctor(ChainAnalises.Classes.Root.IBaseObject,ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
            </summary>
            <param name="pkey"></param>
            <param name="pvalue"></param>
        </member>
        <member name="M:ChainAnalises.Classes.Statistics.DictionaryEntryBase.#ctor(ChainAnalises.Classes.Statistics.DictionaryEntryBaseStruct)">
            <summary>
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ChainAnalises.Classes.Statistics.DictionaryEntryBase.GetDataStruct">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="P:ChainAnalises.Classes.Statistics.DictionaryEntryBase.Key">
            <summary>
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.Statistics.DictionaryEntryBase.Value">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.Statistics.DictionaryEntryBaseStruct">
            <summary>
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.Root.SimpleTypes.ValueDouble">
            <summary>
             Класс - вещественное значение
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueDouble.#ctor(System.Double)">
            <summary>
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueDouble.#ctor(ChainAnalises.Classes.Root.SimpleTypes.ValueDoubleBin)">
            <summary>
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueDouble.Clone">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueDouble.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            true if the specified <see cref="T:System.Object"></see> is equal to the current <see cref="T:System.Object"></see>; otherwise, false.
            </returns>
            
            <param name="obj">The <see cref="T:System.Object"></see> to compare with the current <see cref="T:System.Object"></see>. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueDouble.op_Implicit(ChainAnalises.Classes.Root.SimpleTypes.ValueDouble)~System.Double">
            <summary>
            </summary>
            <param name="From"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueDouble.op_Implicit(System.Double)~ChainAnalises.Classes.Root.SimpleTypes.ValueDouble">
            <summary>
            </summary>
            <param name="from"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.Root.SimpleTypes.ValueDoubleBin">
            <summary>
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueDoubleBin.#ctor(System.Double)">
            <summary>
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Volume">
            <summary>
             Объём цепи. Произведение длин всех её интервалов.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Volume.Calculate(ChainAnalises.Classes.IntervalAnalysis.Chain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.DescriptiveInformation">
            <summary>
             Число описательных информаций.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.DescriptiveInformation.Calculate(ChainAnalises.Classes.IntervalAnalysis.Chain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.AverageRemoteness">
            <summary>
             Среднегеометрическая удалённость,
             логарифм по основанию 2 от среднегеометрического интервала.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.AverageRemoteness.Calculate(ChainAnalises.Classes.IntervalAnalysis.Chain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.Root.SimpleTypes.ValueString">
            <summary>
             Класс представляющий элемент-строку
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueString.#ctor(System.String)">
            <summary>
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueString.Equals(System.Object)">
            <summary>
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueString.op_Implicit(ChainAnalises.Classes.Root.SimpleTypes.ValueString)~System.String">
            <summary>
            </summary>
            <param name="From"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.Root.SimpleTypes.ValueString.op_Implicit(System.String)~ChainAnalises.Classes.Root.SimpleTypes.ValueString">
            <summary>
            </summary>
            <param name="from"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.ArithmeticMean">
            <summary>
             Среднее арифметическое значение длин интервалов.
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.ArithmeticMean.Calculate(ChainAnalises.Classes.IntervalAnalysis.UniformChain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            Для однородной цепи данная характеристика 
            вычисляется как 1/вероятность или чеастоту её элемента.
            </summary>
            <param name="chain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.ArithmeticMean.Calculate(ChainAnalises.Classes.IntervalAnalysis.Chain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
             Вычисляется как среднее значение от среднего интервала однородных цепей
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.NormalizedAverageRemoteness">
            <summary>
             Нормализованная средняя удалённость
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.AlphabetPower">
            <summary>
             Мощность алфавита.
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.EventTheory.ReadPath">
            <summary>
            Класс реализующий объект Маршрут
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.ReadPath.#ctor(ChainAnalises.Classes.EventTheory.Place)">
            <summary>
             Конструктор
            </summary>
            <param name="First">первый элемент пути</param>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.ReadPath.Add(ChainAnalises.Classes.EventTheory.Place)">
            <summary>
             Метод добавляет Место в путь чтений.
            </summary>
            <param name="ToRule">место добавляемое в путь чтения. Должно быть совместимым с пространством которому принадлежит данный путь</param>
            <exception cref="T:System.Exception">В случае если место не совместимо с пространстовом или уже имеется в данном пути вызывается исключение</exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.ReadPath.Remove">
            <summary>
             Удаляет последний элемент пути
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.ReadPath.EqualAsReadPath(ChainAnalises.Classes.EventTheory.ReadPath)">
            <summary>
             Метод сравнимвающий Пути чтения
            </summary>
            <param name="b">путь чтения с которым сравниваем</param>
            <returns>true если пути состоят из одинаковых элементов</returns>
            <exception cref="T:System.NullReferenceException">В случае сравнения с null или путем принадлежащем несовместимому пространству вызывается исключение</exception>
        </member>
        <member name="M:ChainAnalises.Classes.EventTheory.ReadPath.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.ReadPath.Item(System.Int32)">
            <summary>
             Свойство позволяющее получить доступ к любому элементу пути
            </summary>
            <param name="index">Номер элемента</param>
            <returns>Объект Место</returns>
            <exception cref="T:System.Exception">В случае если номер элемента выходит за границы размера массива вызывается исключение</exception>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.ReadPath.Pattern">
            <summary>
            Свойство позволяющее получить паттерн пространства
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.EventTheory.ReadPath.Length">
            <summary>
             Длина пути
             Всегда >= 1
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Probability">
            <summary>
             Вероятность (частота).
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.Probability.Calculate(ChainAnalises.Classes.IntervalAnalysis.Chain,ChainAnalises.Classes.IntervalAnalysis.LinkUp)">
            <summary>
            Для неоднородной, заполненной цепи всегда равна 1.
            </summary>
            <param name="pChain"></param>
            <param name="Link"></param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.IntervalAnalysis.Characteristics.Calculators.NomalizationGamut">
            <summary>
             Удалённость приходящаяся на одно сообщение.
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorEnd`2">
            <summary>
             Итератор перемещающийся с конца цепи к началу.
            </summary>
            <typeparam name="ChainReturn">Тип возвращаемой цепи (Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
            <typeparam name="ChainToIterate">Тип цепи по которой перемещается итератор(Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
        </member>
        <member name="T:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorBase`2">
            <summary>
             Базовый класс итератор по цепочке.
            </summary>
            <typeparam name="ChainReturn">Тип возвращаемой цепи (Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
            <typeparam name="ChainToIterate">Тип цепи по которой перемещается итератор(Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
        </member>
        <member name="T:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IIterator`2">
            <summary>
             Интерфейс итератор по цепочке.
            </summary>
            <typeparam name="ChainRetrun">Тип возвращаемой цепи (Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
            <typeparam name="ChainToIterate">Тип цепи по которой перемещается итератор(Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IIterator`2.Next">
            <summary>
             Перемещает итератор на следующую позицию.
            </summary>
            <returns>Возвращает False если  при перемещении обнаруживается конец цепи. Иначе True</returns>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IIterator`2.Reset">
            <summary>
             Перемещает итератор в начальную позицию.
             Начальная позиция итератора -шаг итерации. То есть для считывания первого значения требуется предварительно вызвать Next()
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IIterator`2.Current">
            <summary>
             Возвращает текущее значение итератора.
            </summary>
            <returns>Текущее значение итератора.</returns>
        </member>
        <member name="F:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorBase`2.pLength">
            <summary>
             Длинна возвращаемого фрагмента цепи
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorBase`2.pStep">
            <summary>
             Шаг итерации
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorBase`2.ptoIterate">
            <summary>
             Цепь по которой будет перемещатся итератор
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorBase`2.pos">
            <summary>
             Текушая позиция итератора
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorBase`2.maxcount">
            <summary>
             Максимальное кол-во смещений
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorBase`2.#ctor(`1,System.Int32,System.Int32)">
            <summary>
             Конструктор
            </summary>
            <param name="toIterate">Цепь по которой будет перемещатся итератор</param>
            <param name="length">Длинна возвращаемого фрагмента цепи</param>
            <param name="step">Шаг итерации</param>
            <exception cref="T:System.Exception">В случае если toIterate == null или длинна передаваемой цепи меньше или равно 0 или меньше length</exception>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorBase`2.Next">
            <summary>
             Перемещает итератор на следующую позицию.
            </summary>
            <returns>Возвращает False если  при перемещении обнаруживается конец цепи. Иначе True</returns>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorBase`2.Current">
            <summary>
             Возвращает текущее значение итератора.
            </summary>
            <returns>Текущее значение итератора.</returns>
            <exception cref="T:System.Exception">В случае если пытаемся считать  значение за пределами цепи</exception>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorBase`2.Reset">
            <summary>
             Перемещает итератор в начальную позицию.
             Начальная позиция итератора -1. То есть для считывания первого значения требуется предварительно вызвать Next()
            </summary>
        </member>
        <member name="P:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorBase`2.MaxStepCount">
            <summary>
             Максимальное кол-во смещений
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorEnd`2.#ctor(`1,System.Int32,System.Int32)">
            <summary>
             Конструктор
            </summary>
            <param name="toIterate">Цепь по которой будет перемещатся итератор</param>
            <param name="length">Длинна возвращаемого фрагмента цепи</param>
            <param name="step">Шаг итерации</param>
            <exception cref="T:System.Exception">В случае если toIterate == null или длинна передаваемой цепи меньше или равно 0 или меньше length</exception>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorEnd`2.Next">
            <summary>
             Перемещает итератор на следующую позицию.
            </summary>
            <returns>Возвращает False если  при перемещении обнаруживается начало цепи. Иначе True</returns>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorEnd`2.Reset">
            <summary>
             Перемещает итератор в начальную позицию.
             Для считывания первого значения требуется предварительно вызвать Next()
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IWritableIterator`2">
            <summary>
             Интерфейс итератора позволяющего писать занчение в позицию цепи.
             Длинна возварщаемого фрамгмента цепи и шаг должны быть равны 1. 
            </summary>
            <typeparam name="ChainReturn">Тип возвращаемой цепи (Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
            <typeparam name="ChainToIterate">Тип цепи по которой перемещается итератор(Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IWritableIterator`2.SetCurrent(ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
             Устанавливает значение в ячейку на которую указывает итератор
            </summary>
            <param name="value">Заначение которое присваеваем ячейке</param>
        </member>
        <member name="T:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1">
            <summary>
            </summary>
            <typeparam name="ChainToIterate"></typeparam>
        </member>
        <member name="F:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1.pLength">
            <summary>
             Длинна возвращаемого фрагмента цепи
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1.pStep">
            <summary>
             Шаг итерации
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1.ptoIterate">
            <summary>
             Цепь по которой будет перемещатся итератор
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1.pos">
            <summary>
             Текушая позиция итератора
            </summary>
        </member>
        <member name="F:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1.maxcount">
            <summary>
             Максимальное кол-во смещений
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1.#ctor(`0,System.Int32)">
            <summary>
             Конструктор
            </summary>
            <param name="toIterate">Цепь по которой будет перемещатся итератор</param>
            <param name="step">Шаг итерации</param>
            <exception cref="T:System.Exception">В случае если toIterate == null или длинна передаваемой цепи меньше или равно 0 или меньше length</exception>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1.Next">
            <summary>
             Перемещает итератор на следующую позицию.
            </summary>
            <returns>Возвращает False если  при перемещении обнаруживается конец цепи. Иначе True</returns>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1.Current">
            <summary>
             Возвращает текущее значение итератора.
            </summary>
            <returns>Текущее значение итератора.</returns>
            <exception cref="T:System.Exception">В случае если пытаемся считать  значение за пределами цепи</exception>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1.ActualPosition">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1.Reset">
            <summary>
             Перемещает итератор в начальную позицию.
             Начальная позиция итератора -шаг. То есть для считывания первого значения требуется предварительно вызвать Next()
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1.Move(System.Int32)">
            <summary>
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorSimpleStart`1.MaxStepCount">
            <summary>
             Максимальное кол-во смещений
            </summary>
        </member>
        <member name="T:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorWritableEnd`2">
            <summary>
             Итератор перемещающийся с конца цепи к началу.
             Позваляет записывать значения в цепь.
            </summary>
            <typeparam name="ChainReturn">Тип возвращаемой цепи (Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
            <typeparam name="ChainToIterate">Тип цепи по которой перемещается итератор(Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorWritableEnd`2.#ctor(`1)">
            <summary>
             Конструктор
             Длинна фрагмента возвращаемой цепи = 1.
             Шаг итерации = 1.
            </summary>
            <param name="toIterate">Цепь по которой будет перемещатся итератор</param>
            <exception cref="T:System.Exception">В случае если toIterate == null или длинна передаваемой цепи меньше или равно 0 или меньше length</exception>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorWritableEnd`2.SetCurrent(ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
             Устанавливает значение в ячейку на которую указывает итератор
            </summary>
            <param name="baseObject">Заначение которое присваеваем ячейке</param>
        </member>
        <member name="T:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorStart`2">
            <summary>
             Итератор перемещающийся с начала цепи к концу.
            </summary>
            <typeparam name="ChainReturn">Тип возвращаемой цепи (Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
            <typeparam name="ChainToIterate">Тип цепи по которой перемещается итератор(Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorStart`2.#ctor(`1,System.Int32,System.Int32)">
            <summary>
             Конструктор
            </summary>
            <param name="toIterate">Цепь по которой будет перемещатся итератор</param>
            <param name="length">Длинна возвращаемого фрагмента цепи</param>
            <param name="step">Шаг итерации</param>
            <exception cref="T:System.Exception">В случае если toIterate == null или длинна передаваемой цепи меньше или равно 0 или меньше length</exception>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorStart`2.Next">
            <summary>
             Перемещает итератор на следующую позицию.
            </summary>
            <returns>Возвращает False если  при перемещении обнаруживается конец цепи. Иначе True</returns>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorStart`2.Reset">
            <summary>
             Перемещает итератор в начальную позицию.
             Начальная позиция итератора -шаг. То есть для считывания первого значения требуется предварительно вызвать Next()
            </summary>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorStart`2.Move(System.Int32)">
            <summary>
             Перемещает итератор на заданную позицию
            </summary>
            <param name="i">Позиция на которую перемещаемся</param>
            <returns></returns>
        </member>
        <member name="T:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorWritableStart`2">
            <summary>
             Итератор перемещающийся с начала цепи к концу.
             Позваляет записывать значения в цепь.
            </summary>
            <typeparam name="ChainReturn">Тип возвращаемой цепи (Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
            <typeparam name="ChainToIterate">Тип цепи по которой перемещается итератор(Потомок класса BaseChain и имеет непереметризированный конструктор)</typeparam>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorWritableStart`2.#ctor(`1)">
            <summary>
             Конструктор
             Длинна фрагмента возвращаемой цепи = 1.
             Шаг итерации = 1.
            </summary>
            <param name="toIterate">Цепь по которой будет перемещатся итератор</param>
            <exception cref="T:System.Exception">В случае если toIterate == null или длинна передаваемой цепи меньше или равно 0 или меньше length</exception>
        </member>
        <member name="M:ChainAnalises.Classes.AuxiliaryClasses.DataManipulators.Iterators.IteratorWritableStart`2.SetCurrent(ChainAnalises.Classes.Root.IBaseObject)">
            <summary>
             Устанавливает значение в ячейку на которую указывает итератор
            </summary>
            <param name="value">Заначение которое присваеваем ячейке</param>
        </member>
    </members>
</doc>
